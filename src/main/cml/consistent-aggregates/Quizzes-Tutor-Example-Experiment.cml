/* Example Context Map for Quizzes Tutor Example */
ContextMap QuizzesTutor {
	contains TournamentContext, CourseExecutionContext, TopicContext, QuizContext

	TournamentContext [SK]<->[SK] CourseExecutionContext

	TournamentContext [D]<-[U] TopicContext

	TournamentContext [D]<-[U] QuizContext
} 

BoundedContext CourseExecutionContext { 
	Application { 
		Service CourseExecutionServices { 
			void removeCourseExecution(Integer courseExecutionId)
			{
				CourseExecutionEntity courseExecution = findCourseExecutionById(courseExecutionId);
				delete courseExecution;
				publish RemoveCourseExecutionEvent(courseExecution.id)
			}
			void removeStudentFromCourseExecution(Integer courseExecutionId, Integer studentId)
			{
				CourseExecutionEntity courseExecution = findCourseExecutionById(courseExecutionId);
				courseExecution.students = courseExecution.students.filter(student -> student.studentId != studentId);
				publish UnenrolledStudentEvent(courseExecutionId,studentId)
			}
			@CourseExecutionValue getCourseExecutionByCourseExecutionId(Integer courseExecutionId)
			{
				CourseExecution courseExecution = findCourseExecutionById(courseExecutionId);
				return CourseExecutionValue(courseExecution) 
			}
			@Student getStudentByCourseExecutionIdAndStudentId(Integer courseExecutionId, Integer studentId)
			{
				Student student = findStudentByCourseExecutionIdAndByStudentId(courseExecutionId, studentId);
				return StudentValue(student)
			}
		}
	}
	Aggregate CourseExecutionAggregate {
		// The domain event is declared in the aggregate, this is already supported by the grammar
		DomainEvent RemoveCourseExecutionEvent {
			Integer aggregateId
			// The domain event constructor, not supported by the grammar
			def void RemoveCourseExecutionEvent(Integer id) { 
				this.aggregateId = id
			}
		}
		DomainEvent UnenrolledStudentEvent {
			int aggregateId
			Integer studentId
			// another event constructor
			def void UnenrolledStudentEvent(int id, Integer studentId) {
				this.aggregateId = id;
				this.studentId = studentId
			}
		}
		ValueObject CourseExecutionValue {
			int id
			String acronym
			def void CourseExecutionValue(@CourseExecutionEntity courseExecutionEntity) {
				this.id = courseExecutionEntity.id; 
				this.acronym = courseExecutionEntity.acronym
			}
		}
		ValueObject StudentValue {
			Integer id
			Integer studentId
			String name 
			String username
			DateTime enrollTime
			def void StudentValue(@CourseExecutionEntity courseExecutionEntity, @Student student) { 
				this.id = courseExecutionEntity.id;
				this.studentId = student.id;
				this.name = student.name;
				this.username = student.username; 
				this.enrollTime = now
			}
		}
		Entity CourseExecutionEntity {
			aggregateRoot
			Integer id key
			String courseId
			String acronym
			- List<Student> students
			Repository CourseExecutionRepository {
				@CourseExecutionEntity findCourseExecutionById(Integer courseExecutionId);
				@Student findStudentByCourseExecutionIdAndByStudentId(Integer courseExecutionId, Integer studentId);
			}
		}
		Entity Student {
			Integer id key
			String name
			String username
		}
	}
}

BoundedContext TopicContext {
	Aggregate TopicAggregate{
		ValueObject TopicValue {
			int id
			String name
			def void TopicValue(@TopicEntity topicEntity) { 
				this.id = topicEntity.id; 
				this.name = topicEntity.name
			}
		}
		Entity TopicEntity {
			aggregateRoot
			Integer id key
			String courseId
			String name
			Repository TopicRepository {
				@TopicEntity findTopicById(String id);
			}
		}
	}
}

BoundedContext QuizContext {
	Application {
		Service QuizServices {
			@QuizValue generateQuiz();
		}
	}
	Aggregate QuizAggregate {
		ValueObject QuizValue {
			Integer id 
			DateTime availableDate
			DateTime conclusionDate
			int numberOfQuestions
			def void QuizValue(@QuizEntity quizEntity) {
				this.id = quizEntity.id; 
				this.availableDate = quizEntity.availableDate;
				this.conclusionDate = quizEntity.conclusionDate;
				this.numberOfQuestions = quizEntity.quizQuestions.count() 
			}
		}
		Entity QuizEntity {
			aggregateRoot
			Integer id key
			String courseExecutionId 
			DateTime availableDate
			DateTime conclusionDate
			- List<QuizQuestion> quizQuestions
			Repository QuizRepository {
				@QuizEntity findQuizById(String id);
			}
		}
		Entity QuizQuestion {
			String question
		}
	}
}

BoundedContext TournamentContext {
	Application {
		Functionality void removeCourseExecutionFunctionality(@TournamentValue tournamentValue) {
			TournamentContext.TournamentServices.removeTournamentService(tournamentValue);
		}
			
		Functionality void unenrolledStudentFunctionality(@Tournament tournamentValue, @UnenrolledStudentEvent usEvent) { 
			TournamentContext.TournamentServices.unenrolledStudentService(tournamentValue.id, usEvent); 
		}
		
		Functionality void createTournamentFunctionality(@TournamentValue tournamentValue) { 
			CourseExecutionValue courseExecutionValue = CourseExecutionContext.CourseExecutionServices.getCourseExecutionByCourseExecutionId(tournamentValue);
			QuizValue quizValue = QuizContext.QuizServices.generateQuiz(tournamentValue.tournamentTopics);
			TournamentContext.TournamentServices.createTournament(tournamentValue, courseExecutionValue, quizValue);
		}
		
		Functionality void addParticipantFunctionality(Integer tournamentId, Integer courseExecutionEntityId, Integer studentId) {
			CourseExecutionValue courseExecutionValue = CourseExecutionContext.CourseExecutionServices.getCourseExecutionByCourseExecutionId(courseExecutionEntityId);
			StudentValue studentValue = CourseExecutionContext.CourseExecutionServices.getStudentByCourseExecutionIdAndStudentId(courseExecutionEntityId, studentId);
			TournamentValue tournamentValue = TournamentContext.TournamentServices.getTournamentById(tournamentId);
			TournamentContext.TournamentServices.addParticipant(tournamentValue, studentValue); 
		}
		// The services are atomic transactions	
		Service TournamentServices { 
			// this functionality handles event RemoveCourseExecutionEvent and deletes tournament
			void removeTournamentService(@TournamentValue tournamentValue)
			{
				Tournament tournament = findTournamentById(tournamentValue.id);          
				delete tournament
			}
			void unenrolledStudentService(@TournamentValue tournamentValue, @UnenrolledStudentEvent usEvent)
			{
				Tournament tournament = findTournamentById(tournamentValue.id);
				tournament.participants
					= tournament.participants.filter(participant -> participant.id != usEvent.studentId)
			}
			@TournamentValue getTournamentById(Integer tournamentId) {
				Tournament tournament = findTournamentById(tournamentId);
				return TournamentValue(tournament)
			}
			void createTournament(@TournamentValue tournamentValue, @CourseExecutionValue tournamentCourseExecution, @QuizValue tournamentQuiz)
			{
				create Tournament(tournamentValue)
			}
			void addParticipant(@TournamentValue tournamentValue, @StudentValue studentValue)
			{
				Tournament tournament = findTournamentById(tournamentValue.id); 
				studentValue.enrollTime = now;
				Participant tournamentParticipant = Participant(studentValue)
//				tournament.participants = tournamentParticipants.add(studentValue)
			}
		}
	}
	Aggregate TournamentAggregate {
		handle rceEvent CourseExecutionContext::CourseExecutionAggregate::RemoveCourseExecutionEvent {
			activate root.tournamentCourseExecution.id == rceEvent.aggregateId
			process removeCourseExecutionFunctionality(root)
		}
		handle usEvent CourseExecutionContext::CourseExecutionAggregate::UnenrolledStudentEvent {
			activate root.tournamentCourseExecution.id == usEvent.aggregateId 
						&& root.participants.anyMatch(participant -> participant.id == usEvent.studentId)
			process unenrolledStudentFunctionality(root, usEvent)
		}
		
		ValueObject TournamentValue {
			Integer id
			def void TournamentValue(@Tournament tournament) { 
				this.id = tournament.id
			}
		}
		Entity Tournament {
			aggregateRoot
			Integer id
			DateTime startTime
			DateTime endTime
			- TournamentCreator tournamentCreator
			- TournamentCourseExecution tournamentCourseExecution
			- List<TournamentTopic> tournamentTopics
			- List<Participant> participants
			- TournamentQuiz tournamentQuiz
			
			def void Tournament(@TournamentValue tournamentValue); 
			
			Repository TournamentRepository {
				@Tournament findTournamentById(Integer id);
			}
		}
		Entity TournamentCreator uses CourseExecutionContext::CourseExecutionAggregate::StudentValue
		Entity TournamentCourseExecution uses CourseExecutionContext::CourseExecutionAggregate::CourseExecutionValue
		Entity TournamentTopic uses TopicContext::TopicAggregate::TopicValue
		Entity Participant	uses CourseExecutionContext::CourseExecutionAggregate::StudentValue
		{
			def void Participant(@StudentValue studentValue);
		}
		Entity TournamentQuiz uses QuizContext::QuizAggregate::QuizValue
  
		Invariant courseExecutionIsFinal {
			final root.tournamentCourseExecution.id 
		}

		Invariant finalAfterStart {
			if (now > root.startTime) 
			then (final root.startTime 
				root.endTime
				root.participants
				root.tournamentTopics
				root.tournamentQuiz
			) 
		}

		Invariant startBeforeEnd { 
			root.startTime < root.endTime 
		}
		
		Invariant participantsBelongToCourseExecution {
			root.participants.allMatch(participant -> participant.id == root.tournamentCourseExecution.id)
		}

		Invariant studentDoesNotParticipateTwice {
			root.participants.count() == root.participants.map(participant -> participant.id).distinct().count()
		}
		
		Invariant participantEnrollBeforeStart {
			root.participants.allMatch(participant -> participant.enrollTime < root.startTime)
		}
	}
}

